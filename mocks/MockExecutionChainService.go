// Code generated by mockery v2.53.4. DO NOT EDIT.

package mocks

import (
	context "context"

	models "github.com/sakibcoolz/loki-suite/internal/models"
	mock "github.com/stretchr/testify/mock"

	uuid "github.com/google/uuid"
)

// MockExecutionChainService is an autogenerated mock type for the ExecutionChainService type
type MockExecutionChainService struct {
	mock.Mock
}

type MockExecutionChainService_Expecter struct {
	mock *mock.Mock
}

func (_m *MockExecutionChainService) EXPECT() *MockExecutionChainService_Expecter {
	return &MockExecutionChainService_Expecter{mock: &_m.Mock}
}

// CreateChain provides a mock function with given fields: ctx, req
func (_m *MockExecutionChainService) CreateChain(ctx context.Context, req *models.CreateExecutionChainRequest) (*models.CreateExecutionChainResponse, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for CreateChain")
	}

	var r0 *models.CreateExecutionChainResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.CreateExecutionChainRequest) (*models.CreateExecutionChainResponse, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.CreateExecutionChainRequest) *models.CreateExecutionChainResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.CreateExecutionChainResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.CreateExecutionChainRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockExecutionChainService_CreateChain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateChain'
type MockExecutionChainService_CreateChain_Call struct {
	*mock.Call
}

// CreateChain is a helper method to define mock.On call
//   - ctx context.Context
//   - req *models.CreateExecutionChainRequest
func (_e *MockExecutionChainService_Expecter) CreateChain(ctx interface{}, req interface{}) *MockExecutionChainService_CreateChain_Call {
	return &MockExecutionChainService_CreateChain_Call{Call: _e.mock.On("CreateChain", ctx, req)}
}

func (_c *MockExecutionChainService_CreateChain_Call) Run(run func(ctx context.Context, req *models.CreateExecutionChainRequest)) *MockExecutionChainService_CreateChain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.CreateExecutionChainRequest))
	})
	return _c
}

func (_c *MockExecutionChainService_CreateChain_Call) Return(_a0 *models.CreateExecutionChainResponse, _a1 error) *MockExecutionChainService_CreateChain_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockExecutionChainService_CreateChain_Call) RunAndReturn(run func(context.Context, *models.CreateExecutionChainRequest) (*models.CreateExecutionChainResponse, error)) *MockExecutionChainService_CreateChain_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteChain provides a mock function with given fields: ctx, chainID
func (_m *MockExecutionChainService) DeleteChain(ctx context.Context, chainID uuid.UUID) error {
	ret := _m.Called(ctx, chainID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteChain")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = rf(ctx, chainID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockExecutionChainService_DeleteChain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteChain'
type MockExecutionChainService_DeleteChain_Call struct {
	*mock.Call
}

// DeleteChain is a helper method to define mock.On call
//   - ctx context.Context
//   - chainID uuid.UUID
func (_e *MockExecutionChainService_Expecter) DeleteChain(ctx interface{}, chainID interface{}) *MockExecutionChainService_DeleteChain_Call {
	return &MockExecutionChainService_DeleteChain_Call{Call: _e.mock.On("DeleteChain", ctx, chainID)}
}

func (_c *MockExecutionChainService_DeleteChain_Call) Run(run func(ctx context.Context, chainID uuid.UUID)) *MockExecutionChainService_DeleteChain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockExecutionChainService_DeleteChain_Call) Return(_a0 error) *MockExecutionChainService_DeleteChain_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockExecutionChainService_DeleteChain_Call) RunAndReturn(run func(context.Context, uuid.UUID) error) *MockExecutionChainService_DeleteChain_Call {
	_c.Call.Return(run)
	return _c
}

// ExecuteChain provides a mock function with given fields: ctx, req
func (_m *MockExecutionChainService) ExecuteChain(ctx context.Context, req *models.ExecuteChainRequest) (*models.ExecuteChainResponse, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for ExecuteChain")
	}

	var r0 *models.ExecuteChainResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *models.ExecuteChainRequest) (*models.ExecuteChainResponse, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *models.ExecuteChainRequest) *models.ExecuteChainResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.ExecuteChainResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *models.ExecuteChainRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockExecutionChainService_ExecuteChain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecuteChain'
type MockExecutionChainService_ExecuteChain_Call struct {
	*mock.Call
}

// ExecuteChain is a helper method to define mock.On call
//   - ctx context.Context
//   - req *models.ExecuteChainRequest
func (_e *MockExecutionChainService_Expecter) ExecuteChain(ctx interface{}, req interface{}) *MockExecutionChainService_ExecuteChain_Call {
	return &MockExecutionChainService_ExecuteChain_Call{Call: _e.mock.On("ExecuteChain", ctx, req)}
}

func (_c *MockExecutionChainService_ExecuteChain_Call) Run(run func(ctx context.Context, req *models.ExecuteChainRequest)) *MockExecutionChainService_ExecuteChain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*models.ExecuteChainRequest))
	})
	return _c
}

func (_c *MockExecutionChainService_ExecuteChain_Call) Return(_a0 *models.ExecuteChainResponse, _a1 error) *MockExecutionChainService_ExecuteChain_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockExecutionChainService_ExecuteChain_Call) RunAndReturn(run func(context.Context, *models.ExecuteChainRequest) (*models.ExecuteChainResponse, error)) *MockExecutionChainService_ExecuteChain_Call {
	_c.Call.Return(run)
	return _c
}

// ExecuteChainByEvent provides a mock function with given fields: ctx, tenantID, event, eventData
func (_m *MockExecutionChainService) ExecuteChainByEvent(ctx context.Context, tenantID string, event string, eventData map[string]interface{}) error {
	ret := _m.Called(ctx, tenantID, event, eventData)

	if len(ret) == 0 {
		panic("no return value specified for ExecuteChainByEvent")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, map[string]interface{}) error); ok {
		r0 = rf(ctx, tenantID, event, eventData)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockExecutionChainService_ExecuteChainByEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecuteChainByEvent'
type MockExecutionChainService_ExecuteChainByEvent_Call struct {
	*mock.Call
}

// ExecuteChainByEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - tenantID string
//   - event string
//   - eventData map[string]interface{}
func (_e *MockExecutionChainService_Expecter) ExecuteChainByEvent(ctx interface{}, tenantID interface{}, event interface{}, eventData interface{}) *MockExecutionChainService_ExecuteChainByEvent_Call {
	return &MockExecutionChainService_ExecuteChainByEvent_Call{Call: _e.mock.On("ExecuteChainByEvent", ctx, tenantID, event, eventData)}
}

func (_c *MockExecutionChainService_ExecuteChainByEvent_Call) Run(run func(ctx context.Context, tenantID string, event string, eventData map[string]interface{})) *MockExecutionChainService_ExecuteChainByEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(map[string]interface{}))
	})
	return _c
}

func (_c *MockExecutionChainService_ExecuteChainByEvent_Call) Return(_a0 error) *MockExecutionChainService_ExecuteChainByEvent_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockExecutionChainService_ExecuteChainByEvent_Call) RunAndReturn(run func(context.Context, string, string, map[string]interface{}) error) *MockExecutionChainService_ExecuteChainByEvent_Call {
	_c.Call.Return(run)
	return _c
}

// GetChain provides a mock function with given fields: ctx, chainID
func (_m *MockExecutionChainService) GetChain(ctx context.Context, chainID uuid.UUID) (*models.ExecutionChain, error) {
	ret := _m.Called(ctx, chainID)

	if len(ret) == 0 {
		panic("no return value specified for GetChain")
	}

	var r0 *models.ExecutionChain
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*models.ExecutionChain, error)); ok {
		return rf(ctx, chainID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) *models.ExecutionChain); ok {
		r0 = rf(ctx, chainID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.ExecutionChain)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, chainID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockExecutionChainService_GetChain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetChain'
type MockExecutionChainService_GetChain_Call struct {
	*mock.Call
}

// GetChain is a helper method to define mock.On call
//   - ctx context.Context
//   - chainID uuid.UUID
func (_e *MockExecutionChainService_Expecter) GetChain(ctx interface{}, chainID interface{}) *MockExecutionChainService_GetChain_Call {
	return &MockExecutionChainService_GetChain_Call{Call: _e.mock.On("GetChain", ctx, chainID)}
}

func (_c *MockExecutionChainService_GetChain_Call) Run(run func(ctx context.Context, chainID uuid.UUID)) *MockExecutionChainService_GetChain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockExecutionChainService_GetChain_Call) Return(_a0 *models.ExecutionChain, _a1 error) *MockExecutionChainService_GetChain_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockExecutionChainService_GetChain_Call) RunAndReturn(run func(context.Context, uuid.UUID) (*models.ExecutionChain, error)) *MockExecutionChainService_GetChain_Call {
	_c.Call.Return(run)
	return _c
}

// GetChainRun provides a mock function with given fields: ctx, runID
func (_m *MockExecutionChainService) GetChainRun(ctx context.Context, runID uuid.UUID) (*models.ExecutionChainRun, error) {
	ret := _m.Called(ctx, runID)

	if len(ret) == 0 {
		panic("no return value specified for GetChainRun")
	}

	var r0 *models.ExecutionChainRun
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) (*models.ExecutionChainRun, error)); ok {
		return rf(ctx, runID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) *models.ExecutionChainRun); ok {
		r0 = rf(ctx, runID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.ExecutionChainRun)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = rf(ctx, runID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockExecutionChainService_GetChainRun_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetChainRun'
type MockExecutionChainService_GetChainRun_Call struct {
	*mock.Call
}

// GetChainRun is a helper method to define mock.On call
//   - ctx context.Context
//   - runID uuid.UUID
func (_e *MockExecutionChainService_Expecter) GetChainRun(ctx interface{}, runID interface{}) *MockExecutionChainService_GetChainRun_Call {
	return &MockExecutionChainService_GetChainRun_Call{Call: _e.mock.On("GetChainRun", ctx, runID)}
}

func (_c *MockExecutionChainService_GetChainRun_Call) Run(run func(ctx context.Context, runID uuid.UUID)) *MockExecutionChainService_GetChainRun_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockExecutionChainService_GetChainRun_Call) Return(_a0 *models.ExecutionChainRun, _a1 error) *MockExecutionChainService_GetChainRun_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockExecutionChainService_GetChainRun_Call) RunAndReturn(run func(context.Context, uuid.UUID) (*models.ExecutionChainRun, error)) *MockExecutionChainService_GetChainRun_Call {
	_c.Call.Return(run)
	return _c
}

// ListChainRuns provides a mock function with given fields: ctx, chainID, page, limit
func (_m *MockExecutionChainService) ListChainRuns(ctx context.Context, chainID uuid.UUID, page int, limit int) (*models.ExecutionChainRunsResponse, error) {
	ret := _m.Called(ctx, chainID, page, limit)

	if len(ret) == 0 {
		panic("no return value specified for ListChainRuns")
	}

	var r0 *models.ExecutionChainRunsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, int, int) (*models.ExecutionChainRunsResponse, error)); ok {
		return rf(ctx, chainID, page, limit)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, int, int) *models.ExecutionChainRunsResponse); ok {
		r0 = rf(ctx, chainID, page, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.ExecutionChainRunsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uuid.UUID, int, int) error); ok {
		r1 = rf(ctx, chainID, page, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockExecutionChainService_ListChainRuns_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListChainRuns'
type MockExecutionChainService_ListChainRuns_Call struct {
	*mock.Call
}

// ListChainRuns is a helper method to define mock.On call
//   - ctx context.Context
//   - chainID uuid.UUID
//   - page int
//   - limit int
func (_e *MockExecutionChainService_Expecter) ListChainRuns(ctx interface{}, chainID interface{}, page interface{}, limit interface{}) *MockExecutionChainService_ListChainRuns_Call {
	return &MockExecutionChainService_ListChainRuns_Call{Call: _e.mock.On("ListChainRuns", ctx, chainID, page, limit)}
}

func (_c *MockExecutionChainService_ListChainRuns_Call) Run(run func(ctx context.Context, chainID uuid.UUID, page int, limit int)) *MockExecutionChainService_ListChainRuns_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(int), args[3].(int))
	})
	return _c
}

func (_c *MockExecutionChainService_ListChainRuns_Call) Return(_a0 *models.ExecutionChainRunsResponse, _a1 error) *MockExecutionChainService_ListChainRuns_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockExecutionChainService_ListChainRuns_Call) RunAndReturn(run func(context.Context, uuid.UUID, int, int) (*models.ExecutionChainRunsResponse, error)) *MockExecutionChainService_ListChainRuns_Call {
	_c.Call.Return(run)
	return _c
}

// ListChains provides a mock function with given fields: ctx, tenantID, page, limit
func (_m *MockExecutionChainService) ListChains(ctx context.Context, tenantID string, page int, limit int) (*models.ExecutionChainListResponse, error) {
	ret := _m.Called(ctx, tenantID, page, limit)

	if len(ret) == 0 {
		panic("no return value specified for ListChains")
	}

	var r0 *models.ExecutionChainListResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, int) (*models.ExecutionChainListResponse, error)); ok {
		return rf(ctx, tenantID, page, limit)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int, int) *models.ExecutionChainListResponse); ok {
		r0 = rf(ctx, tenantID, page, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*models.ExecutionChainListResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int, int) error); ok {
		r1 = rf(ctx, tenantID, page, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockExecutionChainService_ListChains_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListChains'
type MockExecutionChainService_ListChains_Call struct {
	*mock.Call
}

// ListChains is a helper method to define mock.On call
//   - ctx context.Context
//   - tenantID string
//   - page int
//   - limit int
func (_e *MockExecutionChainService_Expecter) ListChains(ctx interface{}, tenantID interface{}, page interface{}, limit interface{}) *MockExecutionChainService_ListChains_Call {
	return &MockExecutionChainService_ListChains_Call{Call: _e.mock.On("ListChains", ctx, tenantID, page, limit)}
}

func (_c *MockExecutionChainService_ListChains_Call) Run(run func(ctx context.Context, tenantID string, page int, limit int)) *MockExecutionChainService_ListChains_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(int))
	})
	return _c
}

func (_c *MockExecutionChainService_ListChains_Call) Return(_a0 *models.ExecutionChainListResponse, _a1 error) *MockExecutionChainService_ListChains_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockExecutionChainService_ListChains_Call) RunAndReturn(run func(context.Context, string, int, int) (*models.ExecutionChainListResponse, error)) *MockExecutionChainService_ListChains_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateChain provides a mock function with given fields: ctx, chainID, req
func (_m *MockExecutionChainService) UpdateChain(ctx context.Context, chainID uuid.UUID, req *models.UpdateExecutionChainRequest) error {
	ret := _m.Called(ctx, chainID, req)

	if len(ret) == 0 {
		panic("no return value specified for UpdateChain")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, *models.UpdateExecutionChainRequest) error); ok {
		r0 = rf(ctx, chainID, req)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockExecutionChainService_UpdateChain_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateChain'
type MockExecutionChainService_UpdateChain_Call struct {
	*mock.Call
}

// UpdateChain is a helper method to define mock.On call
//   - ctx context.Context
//   - chainID uuid.UUID
//   - req *models.UpdateExecutionChainRequest
func (_e *MockExecutionChainService_Expecter) UpdateChain(ctx interface{}, chainID interface{}, req interface{}) *MockExecutionChainService_UpdateChain_Call {
	return &MockExecutionChainService_UpdateChain_Call{Call: _e.mock.On("UpdateChain", ctx, chainID, req)}
}

func (_c *MockExecutionChainService_UpdateChain_Call) Run(run func(ctx context.Context, chainID uuid.UUID, req *models.UpdateExecutionChainRequest)) *MockExecutionChainService_UpdateChain_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uuid.UUID), args[2].(*models.UpdateExecutionChainRequest))
	})
	return _c
}

func (_c *MockExecutionChainService_UpdateChain_Call) Return(_a0 error) *MockExecutionChainService_UpdateChain_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockExecutionChainService_UpdateChain_Call) RunAndReturn(run func(context.Context, uuid.UUID, *models.UpdateExecutionChainRequest) error) *MockExecutionChainService_UpdateChain_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockExecutionChainService creates a new instance of MockExecutionChainService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockExecutionChainService(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockExecutionChainService {
	mock := &MockExecutionChainService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
